#!/usr/bin/env bash
# A tiny framework for building *and uninstalling* old tools from source cleanly on Arch/Manjaro.
# Usage:
#   ./build.sh [--debug] [--keep-work] [--phase P] [--no-deps] <recipe>...
#   ./build.sh --uninstall <recipe>...
# Examples:
#   ./build.sh amap
#   ./build.sh --debug apple_bleee 0trace
#   ./build.sh --phase pre amap
#   ./build.sh --phase post --no-deps 0trace
#   ./build.sh --uninstall 0trace amap

set -Eeuo pipefail
IFS=$'\n\t'

# ---------- Global flags / arg parsing ----------
DEBUG=${DEBUG:-0}
RECIPES=()
KEEP_WORK=0
PHASE="all"         # all | deps | pre | fetch | build | install | post | uninstall
INSTALL_DEPS=1

while [[ $# -gt 0 ]]; do
  case "$1" in
    --debug) DEBUG=1; shift ;;
    --keep-work) KEEP_WORK=1; shift ;;
    --phase) PHASE="${2:-}"; shift 2 ;;
    --no-deps) INSTALL_DEPS=0; shift ;;
    --uninstall) PHASE="uninstall"; shift ;;
    --list) find recipes -maxdepth 1 -name '*.sh' -printf '%f\n' | sed 's/\.sh$//'; exit 0 ;;
    -h|--help)
      printf "Usage: %s [--debug] [--keep-work] [--phase P] [--no-deps] <recipe>...\n" "$0"
      printf "       %s --uninstall <recipe>...\n" "$0"
      printf "Phases: all (default), deps, pre, fetch, build, install, post, uninstall\n"
      exit 0 ;;
    --) shift; break ;;
    *) RECIPES+=("$1"); shift ;;
  esac
done

[[ ${#RECIPES[@]} -gt 0 ]] || { printf "\033[1;31m[xx]\033[0m %s\n" "no recipes specified (try --list)"; exit 1; }

# ---------- Logging ----------
log()  { printf "\033[1;34m==>\033[0m %s\n" "$*"; }
warn() { printf "\033[1;33m[!]\033[0m %s\n" "$*"; }
die()  { printf "\033[1;31m[xx]\033[0m %s\n" "$*" >&2; exit 1; }

# ---------- helpers (shared with recipes) ----------
quiet_run() { if (( DEBUG )); then "$@"; else "$@" >/dev/null 2>&1; fi; }
require_cmd() { command -v "$1" &>/dev/null || die "Missing required command: $1"; }
with_sudo() { if [[ $EUID -ne 0 ]]; then sudo "$@"; else "$@"; fi; }

mkwork() {
  local d
  d="$(mktemp -d -p "${1:-/tmp}" srcbuild-XXXXXX)"
  echo "$d"
}

ensure_pkgs() {
  local pkgs=("$@")
  [[ ${#pkgs[@]} -eq 0 ]] && return 0
  require_cmd pacman
  quiet_run with_sudo pacman -S --needed --noconfirm "${pkgs[@]}"
}

clean_env_configure() {
  # args: <dir> [extra env] -- <configure args...>
  local dir=$1; shift
  (
    cd "$dir"
    local envs=() args=() seen=0
    for x in "$@"; do
      if [[ $x == '--' && $seen -eq 0 ]]; then seen=1; continue; fi
      (( seen == 0 )) && envs+=("$x") || args+=("$x")
    done
    CONFIG_SHELL=/bin/bash env -i PATH="/usr/bin:/bin" CC=/usr/bin/gcc CXX=/usr/bin/g++ CFLAGS="-O2" LDFLAGS="" \
      "${envs[@]}" ./configure "${args[@]}"
  )
}

# --- extra helpers that recipes often need for uninstall ---
rm_if_exists() {
  # args: <path>...
  local p rc=0
  for p in "$@"; do
    if [[ -e "$p" || -L "$p" ]]; then
      with_sudo rm -f -- "$p" || rc=1
      log "removed: $p"
    fi
  done
  return $rc
}

rmdir_safe() {
  # args: <dir>...
  local d
  for d in "$@"; do
    with_sudo rmdir --ignore-fail-on-non-empty -- "$d" 2>/dev/null || true
  done
}

refresh_mandb() {
  if command -v mandb >/dev/null 2>&1; then
    log "refreshing man-db"
    with_sudo mandb >/dev/null 2>&1 || warn "mandb refresh failed"
  fi
}

export -f log warn die quiet_run require_cmd with_sudo clean_env_configure rm_if_exists rmdir_safe refresh_mandb

has_phase() {
  local script="$1" phase="$2"
  # naive but effective: look for '^phase()' in the recipe
  grep -qE "^${phase}\(\)" "$script"
}

run_phase() {
  local phase="$1" name="$2" script="$3" work="$4" src="$5"

  # Dependency handling only for 'deps' phase (and when not suppressed)
  if [[ "$phase" == "deps" ]]; then
    mapfile -t deps < <(DEBUG=$DEBUG WORK="$work" SRC="$src" "$script" deps || true)
    [[ ${#deps[@]} -gt 0 && $INSTALL_DEPS -eq 1 ]] && ensure_pkgs "${deps[@]}"
    return 0
  fi

  if has_phase "$script" "$phase"; then
    log "[$name] phase: $phase"
    DEBUG=$DEBUG WORK="$work" SRC="$src" "$script" "$phase"
  else
    warn "[$name] phase '$phase' not implemented; skipping"
  fi
}

# ---------- core runner ----------
run_recipe() {
  local name="$1"
  local script="recipes/${name}.sh"
  [[ -x "$script" ]] || die "recipe not found or not executable: $name"

  local work src success=0
  work="$(mkwork)"
  src="$work/${name}-src"
  mkdir -p "$src"
  export WORK="$work" SRC="$src"

  log "[$name] Work dir: $work"
  trap '
    if (( success==1 )); then
      if (( KEEP_WORK==0 )); then rm -rf "'"$work"'"; else echo "Left work dir: '"$work"'"; fi
    else
      echo "Left work dir for debug: '"$work"'"
    fi
  ' RETURN

  case "$PHASE" in
    all)
      run_phase deps    "$name" "$script" "$work" "$src"
      run_phase pre     "$name" "$script" "$work" "$src"
      run_phase fetch   "$name" "$script" "$work" "$src"
      run_phase build   "$name" "$script" "$work" "$src"
      run_phase install "$name" "$script" "$work" "$src"
      run_phase post    "$name" "$script" "$work" "$src"
      ;;
    deps|pre|fetch|build|install|post)
      # still ensure deps unless --no-deps
      run_phase deps "$name" "$script" "$work" "$src"
      run_phase "$PHASE" "$name" "$script" "$work" "$src"
      ;;
    uninstall)
      # uninstall should never auto-install deps
      run_phase uninstall "$name" "$script" "$work" "$src"
      ;;
    *)
      die "unknown --phase '$PHASE'"
      ;;
  esac

  success=1
  log "[$name] Done"
}

for r in "${RECIPES[@]}"; do
  run_recipe "$r"
done
