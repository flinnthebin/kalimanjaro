#!/usr/bin/env bash
# A tiny framework for building old tools from source cleanly on Arch/Manjaro.
# Usage:
#   ./build.sh [--debug] <recipe> [<recipe> ...]
# Examples:
#   ./build.sh amap
#   ./build.sh --debug apple_bleee 0trace

set -Eeuo pipefail
IFS=$'\n\t'

# ---------- Global flags / arg parsing ----------
DEBUG=${DEBUG:-0}
RECIPES=()
KEEP_WORK=0

while [[ $# -gt 0 ]]; do
  case "$1" in
    --debug) DEBUG=1; shift ;;
    --keep-work) KEEP_WORK=1; shift ;;
    --list) find recipes -maxdepth 1 -name '*.sh' -printf '%f\n' | sed 's/\.sh$//'; exit 0 ;;
    -h|--help) usage; exit 0 ;;
    --) shift; break ;;
    *) RECIPES+=("$1"); shift ;;
  esac
done

[[ ${#RECIPES[@]} -gt 0 ]] || DIE "no recipes specified (try --list)"

# ---------- Logging ----------
log()  { printf "\033[1;34m==>\033[0m %s\n" "$*"; }
warn() { printf "\033[1;33m[!]\033[0m %s\n" "$*"; }
die()  { printf "\033[1;31m[xx]\033[0m %s\n" "$*" >&2; exit 1; }

# ---------- helpers (shared with recipes) ----------

quiet_run() { if (( DEBUG )); then "$@"; else "$@" >/dev/null 2>&1; fi; }
require_cmd() { command -v "$1" &>/dev/null || DIE "Missing required command: $1"; }
with_sudo() { if [[ $EUID -ne 0 ]]; then sudo "$@"; else "$@"; fi; }
mkwork() { mktemp -d -p "${1:-/tmp}" srcbuild-XXXXXX; echo "$d"; }

ensure_pkgs() {
  local pkgs=("$@")
  [[ ${#pkgs[@]} -eq 0 ]] && return 0
  require_cmd pacman
  quiet_run with_sudo pacman -S --needed --noconfirm "${pkgs[@]}"
}

clean_env_configure() {
  # args: <dir> [extra env] -- <configure args...>
  local dir=$1; shift
  (
    cd "$dir"
    local envs=() args=() seen=0
    for x in "$@"; do
      if [[ $x == '--' && $seen -eq 0 ]]; then seen=1; continue; fi
      (( seen == 0 )) && envs+=("$x") || args+=("$x")
    done
    CONFIG_SHELL=/bin/bash env -i PATH="/usr/bin:/bin" CC=/usr/bin/gcc CXX=/usr/bin/g++ CFLAGS="-O2" LDFLAGS="" \
      "${envs[@]}" ./configure "${args[@]}"
  )
}

export -f log warn die quiet_run require_cmd with_sudo clean_env_configure

# ---------- core runner ----------
run_recipe() {
  local name="$1"
  local script="recipes/${name}.sh"
  [[ -x "$script" ]] || DIE "recipe not found or not executable: $name"

  local work src success=0
  work="$(mkwork)"
  src="$work/${name}-src"
  mkdir -p "$src"

  LOG "[$name] Work dir: $work"
  trap 'if (( success==1 )); then
           if (( KEEP_WORK==0 )); then rm -rf "$work"; else echo "Left work dir: $work"; fi
        else
           echo "Left work dir for debug: $work"
        fi' RETURN

  # phases:
  # 1) deps -> install via pacman
  mapfile -t deps < <(DEBUG=$DEBUG WORK="$work" SRC="$src" "$script" deps || true)
  [[ ${#deps[@]} -gt 0 ]] && ensure_pkgs "${deps[@]}"

  # 2) fetch / 3) build / 4) install (recipe handles its own logging)
  DEBUG=$DEBUG WORK="$work" SRC="$src" "$script" fetch
  DEBUG=$DEBUG WORK="$work" SRC="$src" "$script" build
  DEBUG=$DEBUG WORK="$work" SRC="$src" "$script" install

  success=1
  LOG "[$name] Done"
}

for r in "${RECIPES[@]}"; do
  run_recipe "$r"
done
